\documentclass{article}
\title{Fist Tablets}
\author{James Bruska, David Joesephs, Jacob Melite, Benjamin Lannon}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}
Benjamin do this

\section{Problem Description: What is Hnefatafl}
Benjamin do this

\section{Methodology}

\subsection{Game Logic}
James do this

\subsection{AI Algorithm}
	Before any code for the AI could be written, we had to research the optimal algorithm to use, in order to minimize the time it takes for the AI to make a move and to maximize difficulty. Initial research turned up a single paper on Hnefatafl, which stated that Hnefatafl has a branching factor of about 100, about 10 times more than chess, which has a branching factor of around 10-20. The researchers wrote that they used a neural network to create an AI, which I immediately discarded as being too complicated for this project [1]. This led us to asking Professors Sattar, Tamon, and Black for help in creating an AI. Professor Tamon pointed us to a set of algorithms called Branch-and-Bound algorithms, and lent us two books on the topic. Professor Black expanded on Professor Tamon's answer, telling us that the specific Branch-and-Bound algorithm we should use is a Minimax Search with Alpha-Beta Pruning. The algorithm works by assigning a value to each state of the game using an evaluation function, in order to indicate how good the current board state is for either player. The evaluation function we used was based off of the one used in the paper we found. The function is as follows:
\begin{lstlisting}
	(InitialWhitePieces - RemainingWhitePieces) - (InitialBlackPieces - RemainingBlackPieces) + .1*(KingDistance)
\end{lstlisting}
The number of white captures is subtracted from the number of white captures, and the Manhattan Distance of the king to the closest corner is then weighted and added to that. The Manhattan Distance is the number of squares the king has to move in order to reach the nearest corner of the board.
	The way the algorithm works, in a broad sense, is a Depth-First-Search that remembers the best move so far, and removes suboptimal moves while building the tree. 

\subsection{Design Patterns \& Principles}
James do this

\section{Implementation}

\subsection{Task Allocation}
James: Game Logic\newline
Jacob: AI\newline
David: GUI\newline
Benjamin: Networking, Documentation, and Report management

\subsection{Tools}
Benjamin do this (Android Studio)

\subsection{Code Layout}

\subsubsection{GUI}
	The GUI when through many different versions. The first technique that was tried was using image buttons. The thought behind that being a move will have the piece move from one button to another by setting the image of the image button. This was quickly thrown out the window and an image view was then used for the board. At first the board was going to be a 13 by 13 board this means that that there where 169 spots on the board. The problem with this is that the space available to click on one spot on the board is very small. To combat this we decided that a 11 by 11 layout would be a better layout. This necessitated changing some of the game logic code but was revived as a good idea by all members of the group. It was also a valid change. While 13 by 13 is the more common layout there are layout that are 11 by 11 that are still valid versions of the game. 
	Now that we have settled upon a 11 by 11 board we turn our attention to the pieces themselves. There are in total 37 different pieces. 24 black pieces, 12 white pieces, and one called the King piece.  The beginning layout of the pieces are in a very easy to remember order. Besides the King piece which is called kingpiece and starts in the middle all of the pieces are named with their color first followed by their number, for example black1. The counting starts with the first square to have a piece in the upper left corner. The numbering then increases as you go across the board. When you have finish all of the pieces in one row you move down one row, go all the way to the left and continue to increment the number according to the color. This ends up with a configuration that looks like this. The middle numbers are all white and the boarder numbers are the black pieces.
        01 02 03 04 05
              06
      
07            01            08
09         02 03 04         10
11 12   05 06 Kp 07 08   13 14
15         09 10 11         16
17            12            18

              19
        20 21 22 23 24

	When you want to move a piece you have to first click on it to select it. This enables you to be able to select on anywhere on the beard to then move that piece. Where ever you touch if it is a valid place to move the piece will move to that place. This is accomplished by having a on touch command on every piece which is essentially an imageview. When a valid movement place is selected the image view is then moved to that position on the board. The most puzzling part of the GUI was that the movement of the pieces was taking a very long time to happen for no apparent reason. This was discovered when one of the team was working on a virtual machine. Each piece was using an image that was 960 by 960 pixels large for a game piece that was approximately 40 by 40 pixels large. When the image for the pieces was scaled down to 400 by 400 the animation became very snappy and responsive making the game much more playable than before. 

\subsubsection{Game Logic}
James do this

\subsubsection{AI}
Jacob do this

\subsubsection{Networking}
Benjamin do this

\subsection{Testing}
James \& Jacob do this

\subsection{UML}
James do this

\section{Discussion}
We'll all get to this

\section{References}
[1]Hingston, Phillip. (2007). “Evolving Players for an Ancient Game: Hnefatafl.” Computational Intelligence and Games, 2007. CIG 2007. IEEE Symposium on. IEEE, 2007.
\end{document}